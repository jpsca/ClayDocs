import re
import shutil
import typing as t
from pathlib import Path

from bs4 import BeautifulSoup
from html2image import Html2Image
from . import markdownify

from .nav import Page
from .utils import THasRender, logger, print_random_messages


RX_ABS_URL = re.compile(
    r"""\s(src|href|data-[a-z0-9_-]+)\s*=\s*['"](\/(?:[a-z0-9_-][^'"]*)?)[\'"]""",
    re.IGNORECASE,
)
SOCIAL_CARD_SIZE = (1200, 630)


class DocsBuilder(THasRender if t.TYPE_CHECKING else object):
    relativize_static: bool = False
    hti: Html2Image

    # This list stores the page contents (only what's inside #main)
    # re-rendered to markdown from the rendered HTML.
    # All pages will be joined at the end to have all the documentation,
    # in a single markdown document, for LLM training or whatever.
    md_pages: list[str]

    def build(self) -> None:
        if self.build_folder.exists():
            shutil.rmtree(self.build_folder)
        self.build_folder.mkdir(exist_ok=True)
        self.build_folder_static.mkdir(exist_ok=True)

        logger.info("Copying static folder...")
        self._copy_static_folder()

        logger.info("Rendering pages...")
        self.md_pages = []
        self.hti = Html2Image()

        for url in self.nav.pages:
            page = self.nav.get_page(url)
            if not page:
                logger.error(f"Page not found: {url}")
                continue
            self._build_page(page)
            self._build_social_card(page)
            self._markdownify_content(page)

        self._build_markdown_doc()

        logger.info("   ...")
        print_random_messages()
        logger.info("✨ Done! ✨")

    def _build_page(self, page: Page) -> None:
        url = page.url.strip("/")
        filename = f"{url}/index.html".lstrip("/")
        filepath = self.build_folder / filename
        folderpath = filepath.parent
        folderpath.mkdir(parents=True, exist_ok=True)

        logger.info(f"Rendering page {url}")
        html = self.render_page(page, save_content=True)

        logger.info("Relativizing page URLs")
        html = self._fix_urls(html, filename)

        logger.info("Writing file")
        filepath.write_text(html)

    def _build_social_card(self, page: Page) -> None:
        url = page.url.strip("/")
        filename = f"{url}/og-card.html".lstrip("/")
        filepath = self.build_folder / filename
        folderpath = filepath.parent

        logger.info(f"Rendering social card for page {url}")
        html = self.render_social_card(page)
        # The static URLS must be readable without a web server
        # so the image generated by html2image is correct
        html = self._fix_urls(html, filename, relativize_static=True)
        filepath.write_text(html)

        logger.info("Generating social card")
        self.hti.output_path = folderpath
        self.hti.screenshot(
            url=str(filepath),
            size=SOCIAL_CARD_SIZE,
            save_as="og-card.png",
        )
        filepath.unlink()

    def _markdownify_content(self, page: Page) -> None:
        """Re-render to markdown the rendered HTML page content
        """
        logger.info("Re-rendering to markdown the rendered HTML page content")
        html = self._fix_urls(page.content.strip())

        md_content = markdownify.markdownify(
            html,
            heading_style=markdownify.ATX,
            code_language_callback=extract_language,
        )
        md_content = re.sub("\n\n+", "\n\n", md_content.strip())
        if md_content:
            if not md_content.startswith("# "):
                md_content = f"# {page.title}\n\n{md_content}"
            self.md_pages.append(md_content)

    def _build_markdown_doc(self) -> None:
        multilanguage = len(self.nav.toc.keys()) > 1
        for language, toc in self.nav.toc.items():
            doc_parts: list[str] = []
            meta_parts: list[str] = []

            if self.metadata:
                md_meta = self._generate_markdown_meta(language)
                meta_parts.append(md_meta)

            md_toc = generate_markdown_toc(self.nav.get_page, toc)
            meta_parts.append("## Table of contents\n")
            meta_parts.append(md_toc)
            doc_parts.append("\n".join(meta_parts))

            doc_parts.extend(self.md_pages)

            if multilanguage and language != self.nav.default:
                filename = f"documentation-{language}.md"
            else:
                filename = "documentation.md"
            logger.info(f"Writing {filename}...")
            filepath = self.build_folder / filename
            filepath.write_text("\n\n========\n\n".join(doc_parts))

    def _generate_markdown_meta(self, language: str) -> str:
        doc: list[str] = ["----"]
        for key, value in self.metadata.items():
            doc.append(f"{key}: {value}")
        if "language" not in self.metadata:
            doc.append(f"language: {language}")
        doc.append("----")
        if "name" in self.metadata:
            doc.append(f"\n# {self.metadata['name']}\n")
        return "\n".join(doc)


    def _copy_static_folder(self) -> None:
        shutil.copytree(
            self.static_folder,
            self.build_folder_static,
            dirs_exist_ok=True,
        )

    def _fix_urls(
        self,
        html: str,
        filename: str = "/",
        *,
        relativize_static: bool | None = None,
    ) -> str:
        pos = 0
        relativize_static = (
            self.relativize_static
            if relativize_static is None
            else relativize_static
        )

        while True:
            match = RX_ABS_URL.search(html, pos=pos)
            if not match:
                break

            attr, url = match.groups()
            if url.startswith(self.static_url):
                newurl = self._fix_static_url(url)
                if relativize_static:
                    newurl = self._get_relative_url(newurl, filename)
            else:
                newurl = self._get_relative_url(url, filename)
                if not newurl.endswith("/"):
                    newurl = f"{newurl}/"

            logger.info(f"{url} -> {newurl}")
            pos = match.end()
            html = f'{html[:match.start()]} {attr}="{newurl}"{html[pos:]}'

        return html

    def _fix_static_url(self, current_url: str) -> str:
        url = current_url.rsplit("?", 1)[0]

        filepath = self.build_folder_static / url.removeprefix(self.static_url).lstrip(
            "/"
        )
        if not filepath.exists():
            logger.info(f"{filepath} doesn't exists")
            self._download_url(url, filepath)

        return url

    def _download_url(self, url: str, filepath: Path) -> None:
        logger.info(f"Downloading {url}...")
        sf = self.server.application.find_file(url)
        if sf is None:
            logger.error(f"{url} doesn't exists")
            return
        src_path, _ = sf.get_path_and_headers({})
        filepath.parent.mkdir(parents=True, exist_ok=True)
        shutil.copyfile(src_path, filepath)
        logger.info(f"Created {filepath}")

    def _get_relative_url(self, current_url: str, filename: str) -> str:
        filename = filename.removesuffix("index.html")
        depth = filename.count("/")
        url = ("../" * depth) + current_url.lstrip("/")

        if not url.startswith("."):
            url = f"./{url}"
        return url


def extract_language(pre: BeautifulSoup) -> str | None:
    parent = pre.parent
    if not parent:
        return None
    pclass = parent.get("class")
    if not pclass:
        return None
    if not pclass[0].startswith("language-"):
        return None
    return pclass[0].removeprefix("language-")


def generate_markdown_toc(
    get_page: t.Callable[[str], Page | None],
    toc: list,
    *,
    level: int = 0,
    prefix: str = "",
) -> str:
    """
    >>> toc = [
    ...     ["/", "Welcome", None],
    ...     [
    ...         None,
    ...         "Guide",
    ...         [
    ...             ["/guide/", "Quickstart", None],
    ...             ["/guide/components", "Components", None],
    ...             ["/guide/extra", "Extra Arguments", None],
    ...             ["/guide/css-and-js", "Adding CSS and JS", None],
    ...         ],
    ...     ],
    ...     [
    ...         None,
    ...         "UI components",
    ...         [
    ...             ["/ui/", "UI components", None],
    ...             ["/ui/tabs", "Tabs", None],
    ...             ["/ui/popover", "Pop-over", None],
    ...             ["/ui/menu", "Menu (Dropdown)", None],
    ...             ["/ui/accordion", "Accordion", None],
    ...             ["/ui/linkedlist", "Linked Lists", None],
    ...             ["/ui/reldate", "Relative date", None],
    ...         ],
    ...     ],
    ... ]
    >>> fake_get_page = lambda url: None
    >>> print(generate_markdown_toc(fake_get_page, toc))
    1. Welcome
    2. Guide
      2.1. Quickstart
      2.2. Components
      2.3. Extra Arguments
      2.4. Adding CSS and JS
    3. UI components
      3.1. UI components
      3.2. Tabs
      3.3. Pop-over
      3.4. Menu (Dropdown)
      3.5. Accordion
      3.6. Linked Lists
      3.7. Relative date

    """
    markdown = ""
    for index, item in enumerate(toc, start=1):
        url, title, children = item

        if level == 0:
            current_prefix = f"{index}."
        else:
            current_prefix = f"{prefix}{index}."

        indent = "  " * level
        markdown += f"{indent}{current_prefix} {title}\n"

        if children:
            # It's a section, so recursively process children
            markdown += generate_markdown_toc(
                get_page,
                children,
                level=level + 1,
                prefix=current_prefix,
            )
        else:
            # It's a page, so process it's own toc
            page = get_page(url)
            if page and page.toc:
                markdown += generate_markdown_page_toc(
                    page.toc[0]["children"],
                    level=level + 1,
                    prefix=current_prefix,
                )

    return markdown.strip()



def generate_markdown_page_toc(toc: list, *, level: int, prefix: str) -> str:
    """
    >>> toc = [
    ...     {
    ...         "level": 1,
    ...         "name": "Tabs",
    ...         "children": [
    ...             {"level": 2, "name": "Styling states", "children": []},
    ...             {
    ...                 "level": 2,
    ...                 "name": "Component arguments",
    ...                 "children": [
    ...                     {"level": 3, "name": "TabGroup", "children": []},
    ...                     {"level": 3, "name": "TabList", "children": []},
    ...                     {"level": 3, "name": "Tab", "children": []},
    ...                     {"level": 3, "name": "TabPanel", "children": []},
    ...                 ],
    ...             },
    ...             {"level": 2, "name": "Events", "children": []},
    ...         ],
    ...     },
    ... ]
    >>> print(generate_markdown_page_toc(toc, level=0, prefix=""))
    1. Tabs
    1.1. Styling states
    1.2. Component arguments
        1.2.1. TabGroup
        1.2.2. TabList
        1.2.3. Tab
        1.2.4. TabPanel
    1.3. Events

    """
    markdown = ""
    for index, item in enumerate(toc, start=1):
        current_prefix = f"{prefix}{index}."
        indent = "  " * level
        markdown += f"{indent}{current_prefix} {item['name']}\n"

        if item["children"]:
            markdown += generate_markdown_page_toc(
                item["children"],
                level=level + 1,
                prefix=current_prefix,
            )
    return markdown
